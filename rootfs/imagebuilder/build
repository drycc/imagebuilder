#!/usr/bin/env bash
set -eo pipefail
shopt -s expand_aliases
alias podman="podman --cgroup-manager=cgroupfs --events-backend=file"

function clean_before_exit {
    # delay before exiting, so stdout/stderr flushes through the logging system
    pkill -15 caddy
    pkill -15 podman
    sleep 3
}
trap clean_before_exit EXIT

function waiting_process {
    echo -e "\\033[32m---> Waiting $1 running.\\033[0m"
    for i in {0..4}; do
        if ps -C "$1" 1>/dev/null ; then
            sleep 1
            echo -e "\\033[32m---> Process $1 started.\\033[0m"
            break
        else
            if [[ $i == 3 ]]; then
                echo -e "\\033[31m---> Process $1 failed.\\033[0m"
                exit 1
            else
                sleep 3
            fi
        fi
    done
}

log_level="error"
if [[ "${DRYCC_DEBUG}" ]]; then
    log_level="debug"
    unset DRYCC_DEBUG
fi

mkdir -p "${HOME}"/.config/containers
cp -rf /opt/drycc/podman/etc/containers/* "${HOME}"/.config/containers
registries="/etc/imagebuilder/registries.conf"
if [ -f "${registries}" ]; then
    cat "${registries}" > "${HOME}"/.config/containers/registries.conf
fi

podman system service --time 0 &

waiting_process podman
if [[ -n "${TAR_PATH}" ]]; then
    get_object
    tar -xzf /tmp/app.tgz -C /workspace/ && unset TAR_PATH
fi

pack_builder=$(< /etc/imagebuilder/buildpacks tr -d '[:space:]')
if [[ -f .pack-builder ]]; then
    pack_builder=$(< .pack-builder tr -d '[:space:]')
fi

# Get registry and login
if [[ "${DRYCC_REGISTRY_LOCATION}" == "off-cluster" ]] ; then
    podman login \
        --username "${DRYCC_REGISTRY_USERNAME}" \
        --password "${DRYCC_REGISTRY_PASSWORD}" \
        "${DRYCC_REGISTRY_HOST}" \
        --tls-verify=false > /dev/null
else
    # Start registry proxy
    DRYCC_REGISTRY_PROXY_HOST="${DRYCC_REGISTRY_PROXY_HOST:?DRYCC_REGISTRY_PROXY_HOST env required}"
    DRYCC_REGISTRY_PROXY_PORT=$(echo "${DRYCC_REGISTRY_PROXY_HOST}" | awk -F ':' '{print $2}')
    caddy_command="caddy reverse-proxy \
        --from :${DRYCC_REGISTRY_PROXY_PORT} \
        --to ${DRYCC_REGISTRY_HOST}"
    if [[ ${log_level} != "debug" ]] ; then
        caddy_command="${caddy_command} > /dev/null"
    fi
    $caddy_command 2>&1 &
    waiting_process caddy
    podman login \
        --username "${DRYCC_REGISTRY_USERNAME}" \
        --password "${DRYCC_REGISTRY_PASSWORD}" \
        "${DRYCC_REGISTRY_PROXY_HOST}" \
        --tls-verify=false > /dev/null
fi

# Get image name and image tag
image_base_name=$(echo "${IMAGE_NAME}" | awk -F ':' '{print $1}')
image_cache_name="${image_base_name}":cache
image_latest_name="${image_base_name}":latest

# Building
if [[ "${DRYCC_STACK}" == "container" ]] ; then
    echo "---> Building container"
    if [[ $log_level == "debug" ]] ; then
        podman build --tag"${IMAGE_NAME}" --network host .
        podman push "${IMAGE_NAME}" --tls-verify=false
    else
        podman build --quiet --tag "${IMAGE_NAME}" --network host .
        podman push "${IMAGE_NAME}" --quiet --tls-verify=false
    fi
else
    echo "---> Building pack"
    echo "---> Using builder ${pack_builder}"
    # podman connection
    readonly DOCKER_HOST="unix://$(podman info -f "{{.Host.RemoteSocket.Path}}")"
    export DOCKER_HOST
    pack_command="pack build ${IMAGE_NAME} \
            --builder ${pack_builder} \
            --docker-host ${DOCKER_HOST} \
            --previous-image ${image_latest_name} \
            --trust-builder \
            --publish \
            --cache-image ${image_cache_name} \
            --tag ${image_latest_name} \
            --network host"
    if [[ $log_level == "debug" ]] ; then
        pack_command="$pack_command --verbose"
    fi
    if [[ -f .clear-cache ]]; then
        pack_command="$pack_command --clear-cache"
    fi
    $pack_command
fi